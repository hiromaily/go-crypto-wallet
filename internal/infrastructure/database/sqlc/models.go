// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
)

type AccountKeyAccount string

const (
	AccountKeyAccountClient  AccountKeyAccount = "client"
	AccountKeyAccountDeposit AccountKeyAccount = "deposit"
	AccountKeyAccountPayment AccountKeyAccount = "payment"
	AccountKeyAccountStored  AccountKeyAccount = "stored"
)

func (e *AccountKeyAccount) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountKeyAccount(s)
	case string:
		*e = AccountKeyAccount(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountKeyAccount: %T", src)
	}
	return nil
}

type NullAccountKeyAccount struct {
	AccountKeyAccount AccountKeyAccount
	Valid             bool // Valid is true if AccountKeyAccount is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountKeyAccount) Scan(value interface{}) error {
	if value == nil {
		ns.AccountKeyAccount, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountKeyAccount.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountKeyAccount) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountKeyAccount), nil
}

type AccountKeyCoin string

const (
	AccountKeyCoinBtc AccountKeyCoin = "btc"
	AccountKeyCoinBch AccountKeyCoin = "bch"
	AccountKeyCoinEth AccountKeyCoin = "eth"
	AccountKeyCoinXrp AccountKeyCoin = "xrp"
	AccountKeyCoinHyt AccountKeyCoin = "hyt"
)

func (e *AccountKeyCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountKeyCoin(s)
	case string:
		*e = AccountKeyCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountKeyCoin: %T", src)
	}
	return nil
}

type NullAccountKeyCoin struct {
	AccountKeyCoin AccountKeyCoin
	Valid          bool // Valid is true if AccountKeyCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountKeyCoin) Scan(value interface{}) error {
	if value == nil {
		ns.AccountKeyCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountKeyCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountKeyCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountKeyCoin), nil
}

type AddressAccount string

const (
	AddressAccountClient  AddressAccount = "client"
	AddressAccountDeposit AddressAccount = "deposit"
	AddressAccountPayment AddressAccount = "payment"
	AddressAccountStored  AddressAccount = "stored"
)

func (e *AddressAccount) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AddressAccount(s)
	case string:
		*e = AddressAccount(s)
	default:
		return fmt.Errorf("unsupported scan type for AddressAccount: %T", src)
	}
	return nil
}

type NullAddressAccount struct {
	AddressAccount AddressAccount
	Valid          bool // Valid is true if AddressAccount is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAddressAccount) Scan(value interface{}) error {
	if value == nil {
		ns.AddressAccount, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AddressAccount.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAddressAccount) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AddressAccount), nil
}

type AddressCoin string

const (
	AddressCoinBtc AddressCoin = "btc"
	AddressCoinBch AddressCoin = "bch"
	AddressCoinEth AddressCoin = "eth"
	AddressCoinXrp AddressCoin = "xrp"
	AddressCoinHyt AddressCoin = "hyt"
)

func (e *AddressCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AddressCoin(s)
	case string:
		*e = AddressCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for AddressCoin: %T", src)
	}
	return nil
}

type NullAddressCoin struct {
	AddressCoin AddressCoin
	Valid       bool // Valid is true if AddressCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAddressCoin) Scan(value interface{}) error {
	if value == nil {
		ns.AddressCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AddressCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAddressCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AddressCoin), nil
}

type AuthAccountKeyCoin string

const (
	AuthAccountKeyCoinBtc AuthAccountKeyCoin = "btc"
	AuthAccountKeyCoinBch AuthAccountKeyCoin = "bch"
)

func (e *AuthAccountKeyCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthAccountKeyCoin(s)
	case string:
		*e = AuthAccountKeyCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthAccountKeyCoin: %T", src)
	}
	return nil
}

type NullAuthAccountKeyCoin struct {
	AuthAccountKeyCoin AuthAccountKeyCoin
	Valid              bool // Valid is true if AuthAccountKeyCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthAccountKeyCoin) Scan(value interface{}) error {
	if value == nil {
		ns.AuthAccountKeyCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthAccountKeyCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthAccountKeyCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthAccountKeyCoin), nil
}

type AuthFullpubkeyCoin string

const (
	AuthFullpubkeyCoinBtc AuthFullpubkeyCoin = "btc"
	AuthFullpubkeyCoinBch AuthFullpubkeyCoin = "bch"
)

func (e *AuthFullpubkeyCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthFullpubkeyCoin(s)
	case string:
		*e = AuthFullpubkeyCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthFullpubkeyCoin: %T", src)
	}
	return nil
}

type NullAuthFullpubkeyCoin struct {
	AuthFullpubkeyCoin AuthFullpubkeyCoin
	Valid              bool // Valid is true if AuthFullpubkeyCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthFullpubkeyCoin) Scan(value interface{}) error {
	if value == nil {
		ns.AuthFullpubkeyCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthFullpubkeyCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthFullpubkeyCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthFullpubkeyCoin), nil
}

type BtcTxAction string

const (
	BtcTxActionDeposit  BtcTxAction = "deposit"
	BtcTxActionPayment  BtcTxAction = "payment"
	BtcTxActionTransfer BtcTxAction = "transfer"
)

func (e *BtcTxAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BtcTxAction(s)
	case string:
		*e = BtcTxAction(s)
	default:
		return fmt.Errorf("unsupported scan type for BtcTxAction: %T", src)
	}
	return nil
}

type NullBtcTxAction struct {
	BtcTxAction BtcTxAction
	Valid       bool // Valid is true if BtcTxAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBtcTxAction) Scan(value interface{}) error {
	if value == nil {
		ns.BtcTxAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BtcTxAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBtcTxAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BtcTxAction), nil
}

type BtcTxCoin string

const (
	BtcTxCoinBtc BtcTxCoin = "btc"
	BtcTxCoinBch BtcTxCoin = "bch"
)

func (e *BtcTxCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BtcTxCoin(s)
	case string:
		*e = BtcTxCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for BtcTxCoin: %T", src)
	}
	return nil
}

type NullBtcTxCoin struct {
	BtcTxCoin BtcTxCoin
	Valid     bool // Valid is true if BtcTxCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBtcTxCoin) Scan(value interface{}) error {
	if value == nil {
		ns.BtcTxCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BtcTxCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBtcTxCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BtcTxCoin), nil
}

type PaymentRequestCoin string

const (
	PaymentRequestCoinBtc PaymentRequestCoin = "btc"
	PaymentRequestCoinBch PaymentRequestCoin = "bch"
	PaymentRequestCoinEth PaymentRequestCoin = "eth"
	PaymentRequestCoinXrp PaymentRequestCoin = "xrp"
)

func (e *PaymentRequestCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentRequestCoin(s)
	case string:
		*e = PaymentRequestCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentRequestCoin: %T", src)
	}
	return nil
}

type NullPaymentRequestCoin struct {
	PaymentRequestCoin PaymentRequestCoin
	Valid              bool // Valid is true if PaymentRequestCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentRequestCoin) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentRequestCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentRequestCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentRequestCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentRequestCoin), nil
}

type SeedCoin string

const (
	SeedCoinBtc SeedCoin = "btc"
	SeedCoinBch SeedCoin = "bch"
	SeedCoinEth SeedCoin = "eth"
	SeedCoinXrp SeedCoin = "xrp"
	SeedCoinHyt SeedCoin = "hyt"
)

func (e *SeedCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SeedCoin(s)
	case string:
		*e = SeedCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for SeedCoin: %T", src)
	}
	return nil
}

type NullSeedCoin struct {
	SeedCoin SeedCoin
	Valid    bool // Valid is true if SeedCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSeedCoin) Scan(value interface{}) error {
	if value == nil {
		ns.SeedCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SeedCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSeedCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SeedCoin), nil
}

type TxAction string

const (
	TxActionDeposit  TxAction = "deposit"
	TxActionPayment  TxAction = "payment"
	TxActionTransfer TxAction = "transfer"
)

func (e *TxAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxAction(s)
	case string:
		*e = TxAction(s)
	default:
		return fmt.Errorf("unsupported scan type for TxAction: %T", src)
	}
	return nil
}

type NullTxAction struct {
	TxAction TxAction
	Valid    bool // Valid is true if TxAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxAction) Scan(value interface{}) error {
	if value == nil {
		ns.TxAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxAction), nil
}

type TxCoin string

const (
	TxCoinEth TxCoin = "eth"
	TxCoinXrp TxCoin = "xrp"
	TxCoinHyt TxCoin = "hyt"
)

func (e *TxCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxCoin(s)
	case string:
		*e = TxCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for TxCoin: %T", src)
	}
	return nil
}

type NullTxCoin struct {
	TxCoin TxCoin
	Valid  bool // Valid is true if TxCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxCoin) Scan(value interface{}) error {
	if value == nil {
		ns.TxCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxCoin), nil
}

type XrpAccountKeyAccount string

const (
	XrpAccountKeyAccountClient  XrpAccountKeyAccount = "client"
	XrpAccountKeyAccountDeposit XrpAccountKeyAccount = "deposit"
	XrpAccountKeyAccountPayment XrpAccountKeyAccount = "payment"
	XrpAccountKeyAccountStored  XrpAccountKeyAccount = "stored"
)

func (e *XrpAccountKeyAccount) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = XrpAccountKeyAccount(s)
	case string:
		*e = XrpAccountKeyAccount(s)
	default:
		return fmt.Errorf("unsupported scan type for XrpAccountKeyAccount: %T", src)
	}
	return nil
}

type NullXrpAccountKeyAccount struct {
	XrpAccountKeyAccount XrpAccountKeyAccount
	Valid                bool // Valid is true if XrpAccountKeyAccount is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullXrpAccountKeyAccount) Scan(value interface{}) error {
	if value == nil {
		ns.XrpAccountKeyAccount, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.XrpAccountKeyAccount.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullXrpAccountKeyAccount) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.XrpAccountKeyAccount), nil
}

type XrpAccountKeyCoin string

const (
	XrpAccountKeyCoinXrp XrpAccountKeyCoin = "xrp"
)

func (e *XrpAccountKeyCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = XrpAccountKeyCoin(s)
	case string:
		*e = XrpAccountKeyCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for XrpAccountKeyCoin: %T", src)
	}
	return nil
}

type NullXrpAccountKeyCoin struct {
	XrpAccountKeyCoin XrpAccountKeyCoin
	Valid             bool // Valid is true if XrpAccountKeyCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullXrpAccountKeyCoin) Scan(value interface{}) error {
	if value == nil {
		ns.XrpAccountKeyCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.XrpAccountKeyCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullXrpAccountKeyCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.XrpAccountKeyCoin), nil
}

// table for keys for any account
type AccountKey struct {
	// ID
	ID int64
	// coin type code
	Coin AccountKeyCoin
	// key type (bip44, bip49, bip84, bip86, musig2)
	KeyType string
	// account type
	Account AccountKeyAccount
	// address as standard pubkey script that Pays To PubKey Hash (P2PKH)
	P2pkhAddress string
	// p2sh-segwit address
	P2shSegwitAddress string
	// bech32 address
	Bech32Address string
	// taproot address (BIP86)
	TaprootAddress sql.NullString
	// full public key
	FullPublicKey string
	// multisig address
	MultisigAddress string
	// redeedScript after multisig address generated
	RedeemScript string
	// WIF
	WalletImportFormat string
	// index for hd wallet
	Idx int64
	// progress status for address generating
	AddrStatus int8
	// updated date
	UpdatedAt sql.NullTime
}

// table for account pubkey
type Address struct {
	// ID
	ID int64
	// coin type code
	Coin AddressCoin
	// account type
	Account AddressAccount
	// wallet address
	WalletAddress string
	// true: address is allocated(used)
	IsAllocated bool
	// updated date
	UpdatedAt sql.NullTime
}

// table for keys for auth account
type AuthAccountKey struct {
	// ID
	ID int16
	// coin type code
	Coin AuthAccountKeyCoin
	// key type (bip44, bip49, bip84, bip86, musig2)
	KeyType string
	// auth type
	AuthAccount string
	// address as standard pubkey script that Pays To PubKey Hash (P2PKH)
	P2pkhAddress string
	// p2sh-segwit address
	P2shSegwitAddress string
	// bech32 address
	Bech32Address string
	// taproot address (BIP86)
	TaprootAddress sql.NullString
	// full public key
	FullPublicKey string
	// multisig address
	MultisigAddress string
	// redeedScript after multisig address generated
	RedeemScript string
	// WIF
	WalletImportFormat string
	// index for hd wallet
	Idx int64
	// progress status for address generating
	AddrStatus int8
	// updated date
	UpdatedAt sql.NullTime
}

// table for auth key exported from sign db
type AuthFullpubkey struct {
	// ID
	ID int16
	// coin type code
	Coin AuthFullpubkeyCoin
	// auth type
	AuthAccount string
	// full public key
	FullPublicKey string
	// updated date
	UpdatedAt sql.NullTime
}

// table for btc transaction info
type BtcTx struct {
	// transaction ID
	ID int64
	// coin type code
	Coin BtcTxCoin
	// action type
	Action BtcTxAction
	// HEX string for unsigned transaction
	UnsignedHexTx string
	// HEX string for signed transaction
	SignedHexTx string
	// Hash for sent transaction
	SentHashTx string
	// total amount of coin to send
	TotalInputAmount string
	// total amount of coin to receive without fee
	TotalOutputAmount string
	// fee
	Fee string
	// current transaction type
	CurrentTxType int8
	// updated date for unsigned transaction created
	UnsignedUpdatedAt sql.NullTime
	// updated date for signed transaction sent
	SentUpdatedAt sql.NullTime
}

// table for input transaction
type BtcTxInput struct {
	// ID
	ID int64
	// tx table ID
	TxID int64
	// txid for input
	InputTxid string
	// vout for input
	InputVout uint32
	// sender address for input
	InputAddress string
	// sender account for input
	InputAccount string
	// amount of coin to send for input
	InputAmount string
	// block confirmations when unspent rpc returned
	InputConfirmations uint64
	// updated date
	UpdatedAt sql.NullTime
}

// table for output transaction
type BtcTxOutput struct {
	// ID
	ID int64
	// tx table ID
	TxID int64
	// receiver address for output
	OutputAddress string
	// receiver account for output
	OutputAccount string
	// amount of coin to receive
	OutputAmount string
	// true: output is for fee
	IsChange bool
	// updated date
	UpdatedAt sql.NullTime
}

// table for eth transaction detail
type EthDetailTx struct {
	// ID
	ID int64
	// eth_tx table ID
	TxID int64
	// UUID
	Uuid string
	// current transaction type
	CurrentTxType int8
	// sender account
	SenderAccount string
	// sender address
	SenderAddress string
	// receiver account
	ReceiverAccount string
	// receiver address
	ReceiverAddress string
	// amount of coin to receive
	Amount uint64
	// fee
	Fee uint64
	// gas limit
	GasLimit uint32
	// nonce
	Nonce uint64
	// HEX string for unsigned transaction
	UnsignedHexTx string
	// HEX string for signed transaction
	SignedHexTx string
	// Hash for sent transaction
	SentHashTx string
	// updated date for unsigned transaction created
	UnsignedUpdatedAt sql.NullTime
	// updated date for signed transaction sent
	SentUpdatedAt sql.NullTime
}

// table for payment request
type PaymentRequest struct {
	// ID
	ID int64
	// coin type code
	Coin PaymentRequestCoin
	// tx table ID for payment action
	PaymentID sql.NullInt64
	// sender address
	SenderAddress string
	// sender account
	SenderAccount string
	// receiver address
	ReceiverAddress string
	// amount of coin to send
	Amount string
	// true: unsigned transaction is created
	IsDone bool
	// updated date
	UpdatedAt sql.NullTime
}

// table for seed
type Seed struct {
	// ID
	ID int8
	// coin type code
	Coin SeedCoin
	// seed
	Seed string
	// updated date
	UpdatedAt sql.NullTime
}

// table for eth/xrp transaction info
type Tx struct {
	// transaction ID
	ID int64
	// coin type code
	Coin TxCoin
	// action type
	Action TxAction
	// updated date
	UpdatedAt sql.NullTime
}

// table for xrp keys for any account
type XrpAccountKey struct {
	// ID
	ID int64
	// coin type code
	Coin XrpAccountKeyCoin
	// account type
	Account XrpAccountKeyAccount
	// account_id
	AccountID string
	// key_type
	KeyType int8
	// master_key, DEPRECATED
	MasterKey string
	// master_seed
	MasterSeed string
	// master_seed_hex
	MasterSeedHex string
	// public_key
	PublicKey string
	// public_key_hex
	PublicKeyHex string
	// true: this key is for regular key pair
	IsRegularKeyPair bool
	// index for hd wallet
	AllocatedID int64
	// progress status for address generating
	AddrStatus int8
	// updated date
	UpdatedAt sql.NullTime
}

// table for xrp transaction detail
type XrpDetailTx struct {
	// ID
	ID int64
	// xrp_tx table ID
	TxID int64
	// UUID
	Uuid string
	// current transaction type
	CurrentTxType int8
	// sender account
	SenderAccount string
	// sender address
	SenderAddress string
	// receiver account
	ReceiverAccount string
	// receiver address
	ReceiverAddress string
	// amount of coin to receive
	Amount string
	// xrp tx type like Payment
	XrpTxType string
	// tx fee
	Fee string
	// tx flags
	Flags uint64
	// tx LastLedgerSequence
	LastLedgerSequence uint64
	// tx Sequence
	Sequence uint64
	// tx SigningPubKey
	SigningPubkey string
	// tx TxnSignature
	TxnSignature string
	// tx Hash
	Hash string
	// tx earliest_ledger_version after sending tx
	EarliestLedgerVersion uint64
	// signed tx id
	SignedTxID string
	// sent tx blob
	TxBlob string
	// updated date for signed transaction sent
	SentUpdatedAt sql.NullTime
}

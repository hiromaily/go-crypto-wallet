// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account_key.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"strings"
)

const getAccountKeysByAddrStatus = `-- name: GetAccountKeysByAddrStatus :many
SELECT id, coin, account, p2pkh_address, p2sh_segwit_address, bech32_address, full_public_key, multisig_address, redeem_script, wallet_import_format, idx, addr_status, updated_at FROM account_key WHERE coin = ? AND account = ? AND addr_status = ?
`

type GetAccountKeysByAddrStatusParams struct {
	Coin       AccountKeyCoin
	Account    AccountKeyAccount
	AddrStatus int8
}

func (q *Queries) GetAccountKeysByAddrStatus(ctx context.Context, arg GetAccountKeysByAddrStatusParams) ([]AccountKey, error) {
	rows, err := q.db.QueryContext(ctx, getAccountKeysByAddrStatus, arg.Coin, arg.Account, arg.AddrStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountKey
	for rows.Next() {
		var i AccountKey
		if err := rows.Scan(
			&i.ID,
			&i.Coin,
			&i.Account,
			&i.P2pkhAddress,
			&i.P2shSegwitAddress,
			&i.Bech32Address,
			&i.FullPublicKey,
			&i.MultisigAddress,
			&i.RedeemScript,
			&i.WalletImportFormat,
			&i.Idx,
			&i.AddrStatus,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountKeysByMultisigAddresses = `-- name: GetAccountKeysByMultisigAddresses :many
SELECT id, coin, account, p2pkh_address, p2sh_segwit_address, bech32_address, full_public_key, multisig_address, redeem_script, wallet_import_format, idx, addr_status, updated_at FROM account_key WHERE coin = ? AND account = ? AND multisig_address IN (/*SLICE:addrs*/?)
`

type GetAccountKeysByMultisigAddressesParams struct {
	Coin    AccountKeyCoin
	Account AccountKeyAccount
	Addrs   []string
}

func (q *Queries) GetAccountKeysByMultisigAddresses(ctx context.Context, arg GetAccountKeysByMultisigAddressesParams) ([]AccountKey, error) {
	query := getAccountKeysByMultisigAddresses
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Coin)
	queryParams = append(queryParams, arg.Account)
	if len(arg.Addrs) > 0 {
		for _, v := range arg.Addrs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:addrs*/?", strings.Repeat(",?", len(arg.Addrs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:addrs*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountKey
	for rows.Next() {
		var i AccountKey
		if err := rows.Scan(
			&i.ID,
			&i.Coin,
			&i.Account,
			&i.P2pkhAddress,
			&i.P2shSegwitAddress,
			&i.Bech32Address,
			&i.FullPublicKey,
			&i.MultisigAddress,
			&i.RedeemScript,
			&i.WalletImportFormat,
			&i.Idx,
			&i.AddrStatus,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxAccountKeyIndex = `-- name: GetMaxAccountKeyIndex :one
SELECT COALESCE(MAX(idx), 0) as max_idx FROM account_key WHERE coin = ? AND account = ?
`

type GetMaxAccountKeyIndexParams struct {
	Coin    AccountKeyCoin
	Account AccountKeyAccount
}

func (q *Queries) GetMaxAccountKeyIndex(ctx context.Context, arg GetMaxAccountKeyIndexParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxAccountKeyIndex, arg.Coin, arg.Account)
	var max_idx interface{}
	err := row.Scan(&max_idx)
	return max_idx, err
}

const getOneAccountKeyByMaxID = `-- name: GetOneAccountKeyByMaxID :one
SELECT id, coin, account, p2pkh_address, p2sh_segwit_address, bech32_address, full_public_key, multisig_address, redeem_script, wallet_import_format, idx, addr_status, updated_at FROM account_key WHERE coin = ? AND account = ? ORDER BY id DESC LIMIT 1
`

type GetOneAccountKeyByMaxIDParams struct {
	Coin    AccountKeyCoin
	Account AccountKeyAccount
}

func (q *Queries) GetOneAccountKeyByMaxID(ctx context.Context, arg GetOneAccountKeyByMaxIDParams) (AccountKey, error) {
	row := q.db.QueryRowContext(ctx, getOneAccountKeyByMaxID, arg.Coin, arg.Account)
	var i AccountKey
	err := row.Scan(
		&i.ID,
		&i.Coin,
		&i.Account,
		&i.P2pkhAddress,
		&i.P2shSegwitAddress,
		&i.Bech32Address,
		&i.FullPublicKey,
		&i.MultisigAddress,
		&i.RedeemScript,
		&i.WalletImportFormat,
		&i.Idx,
		&i.AddrStatus,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAccountKey = `-- name: InsertAccountKey :execresult
INSERT INTO account_key (
  coin, account, p2pkh_address, p2sh_segwit_address, bech32_address,
  full_public_key, multisig_address, redeem_script, wallet_import_format, idx, addr_status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertAccountKeyParams struct {
	Coin               AccountKeyCoin
	Account            AccountKeyAccount
	P2pkhAddress       string
	P2shSegwitAddress  string
	Bech32Address      string
	FullPublicKey      string
	MultisigAddress    string
	RedeemScript       string
	WalletImportFormat string
	Idx                int64
	AddrStatus         int8
}

func (q *Queries) InsertAccountKey(ctx context.Context, arg InsertAccountKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertAccountKey,
		arg.Coin,
		arg.Account,
		arg.P2pkhAddress,
		arg.P2shSegwitAddress,
		arg.Bech32Address,
		arg.FullPublicKey,
		arg.MultisigAddress,
		arg.RedeemScript,
		arg.WalletImportFormat,
		arg.Idx,
		arg.AddrStatus,
	)
}

const updateAccountKeyAddrStatus = `-- name: UpdateAccountKeyAddrStatus :execresult
UPDATE account_key SET addr_status = ?, updated_at = ?
WHERE coin = ? AND account = ? AND wallet_import_format = ?
`

type UpdateAccountKeyAddrStatusParams struct {
	AddrStatus         int8
	UpdatedAt          sql.NullTime
	Coin               AccountKeyCoin
	Account            AccountKeyAccount
	WalletImportFormat string
}

func (q *Queries) UpdateAccountKeyAddrStatus(ctx context.Context, arg UpdateAccountKeyAddrStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAccountKeyAddrStatus,
		arg.AddrStatus,
		arg.UpdatedAt,
		arg.Coin,
		arg.Account,
		arg.WalletImportFormat,
	)
}

const updateAccountKeyAddress = `-- name: UpdateAccountKeyAddress :execresult
UPDATE account_key SET p2pkh_address = ?, updated_at = ?
WHERE coin = ? AND account = ? AND p2sh_segwit_address = ?
`

type UpdateAccountKeyAddressParams struct {
	P2pkhAddress      string
	UpdatedAt         sql.NullTime
	Coin              AccountKeyCoin
	Account           AccountKeyAccount
	P2shSegwitAddress string
}

func (q *Queries) UpdateAccountKeyAddress(ctx context.Context, arg UpdateAccountKeyAddressParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAccountKeyAddress,
		arg.P2pkhAddress,
		arg.UpdatedAt,
		arg.Coin,
		arg.Account,
		arg.P2shSegwitAddress,
	)
}

const updateAccountKeyMultisigAddr = `-- name: UpdateAccountKeyMultisigAddr :execresult
UPDATE account_key
SET multisig_address = ?, redeem_script = ?, addr_status = ?, updated_at = ?
WHERE coin = ? AND account = ? AND full_public_key = ?
`

type UpdateAccountKeyMultisigAddrParams struct {
	MultisigAddress string
	RedeemScript    string
	AddrStatus      int8
	UpdatedAt       sql.NullTime
	Coin            AccountKeyCoin
	Account         AccountKeyAccount
	FullPublicKey   string
}

func (q *Queries) UpdateAccountKeyMultisigAddr(ctx context.Context, arg UpdateAccountKeyMultisigAddrParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAccountKeyMultisigAddr,
		arg.MultisigAddress,
		arg.RedeemScript,
		arg.AddrStatus,
		arg.UpdatedAt,
		arg.Coin,
		arg.Account,
		arg.FullPublicKey,
	)
}

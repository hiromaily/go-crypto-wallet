// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: address.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const getAllAddressStrings = `-- name: GetAllAddressStrings :many
SELECT wallet_address FROM address
WHERE coin = ? AND account = ?
`

type GetAllAddressStringsParams struct {
	Coin    AddressCoin
	Account AddressAccount
}

func (q *Queries) GetAllAddressStrings(ctx context.Context, arg GetAllAddressStringsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllAddressStrings, arg.Coin, arg.Account)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var wallet_address string
		if err := rows.Scan(&wallet_address); err != nil {
			return nil, err
		}
		items = append(items, wallet_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAddresses = `-- name: GetAllAddresses :many
SELECT id, coin, account, wallet_address, is_allocated, updated_at FROM address
WHERE coin = ? AND account = ?
`

type GetAllAddressesParams struct {
	Coin    AddressCoin
	Account AddressAccount
}

func (q *Queries) GetAllAddresses(ctx context.Context, arg GetAllAddressesParams) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, getAllAddresses, arg.Coin, arg.Account)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Address
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.Coin,
			&i.Account,
			&i.WalletAddress,
			&i.IsAllocated,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneUnallocatedAddress = `-- name: GetOneUnallocatedAddress :one
SELECT id, coin, account, wallet_address, is_allocated, updated_at FROM address
WHERE coin = ? AND account = ? AND is_allocated = false
LIMIT 1
`

type GetOneUnallocatedAddressParams struct {
	Coin    AddressCoin
	Account AddressAccount
}

func (q *Queries) GetOneUnallocatedAddress(ctx context.Context, arg GetOneUnallocatedAddressParams) (Address, error) {
	row := q.db.QueryRowContext(ctx, getOneUnallocatedAddress, arg.Coin, arg.Account)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.Coin,
		&i.Account,
		&i.WalletAddress,
		&i.IsAllocated,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAddress = `-- name: InsertAddress :execresult
INSERT INTO address (coin, account, wallet_address, is_allocated, updated_at)
VALUES (?, ?, ?, ?, ?)
`

type InsertAddressParams struct {
	Coin          AddressCoin
	Account       AddressAccount
	WalletAddress string
	IsAllocated   bool
	UpdatedAt     sql.NullTime
}

func (q *Queries) InsertAddress(ctx context.Context, arg InsertAddressParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertAddress,
		arg.Coin,
		arg.Account,
		arg.WalletAddress,
		arg.IsAllocated,
		arg.UpdatedAt,
	)
}

const updateAddressIsAllocated = `-- name: UpdateAddressIsAllocated :execresult
UPDATE address
SET is_allocated = ?, updated_at = ?
WHERE coin = ? AND wallet_address = ?
`

type UpdateAddressIsAllocatedParams struct {
	IsAllocated   bool
	UpdatedAt     sql.NullTime
	Coin          AddressCoin
	WalletAddress string
}

func (q *Queries) UpdateAddressIsAllocated(ctx context.Context, arg UpdateAddressIsAllocatedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAddressIsAllocated,
		arg.IsAllocated,
		arg.UpdatedAt,
		arg.Coin,
		arg.WalletAddress,
	)
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: xrp_account_key.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const getXRPAccountKeySecret = `-- name: GetXRPAccountKeySecret :one
SELECT master_seed FROM xrp_account_key WHERE coin = ? AND account = ? AND account_id = ? LIMIT 1
`

type GetXRPAccountKeySecretParams struct {
	Coin      XrpAccountKeyCoin
	Account   XrpAccountKeyAccount
	AccountID string
}

func (q *Queries) GetXRPAccountKeySecret(ctx context.Context, arg GetXRPAccountKeySecretParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getXRPAccountKeySecret, arg.Coin, arg.Account, arg.AccountID)
	var master_seed string
	err := row.Scan(&master_seed)
	return master_seed, err
}

const getXRPAccountKeysByAddrStatus = `-- name: GetXRPAccountKeysByAddrStatus :many
SELECT id, coin, account, account_id, key_type, master_key, master_seed, master_seed_hex, public_key, public_key_hex, is_regular_key_pair, allocated_id, addr_status, updated_at FROM xrp_account_key WHERE coin = ? AND account = ? AND addr_status = ?
`

type GetXRPAccountKeysByAddrStatusParams struct {
	Coin       XrpAccountKeyCoin
	Account    XrpAccountKeyAccount
	AddrStatus int8
}

func (q *Queries) GetXRPAccountKeysByAddrStatus(ctx context.Context, arg GetXRPAccountKeysByAddrStatusParams) ([]XrpAccountKey, error) {
	rows, err := q.db.QueryContext(ctx, getXRPAccountKeysByAddrStatus, arg.Coin, arg.Account, arg.AddrStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []XrpAccountKey
	for rows.Next() {
		var i XrpAccountKey
		if err := rows.Scan(
			&i.ID,
			&i.Coin,
			&i.Account,
			&i.AccountID,
			&i.KeyType,
			&i.MasterKey,
			&i.MasterSeed,
			&i.MasterSeedHex,
			&i.PublicKey,
			&i.PublicKeyHex,
			&i.IsRegularKeyPair,
			&i.AllocatedID,
			&i.AddrStatus,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertXRPAccountKey = `-- name: InsertXRPAccountKey :execresult
INSERT INTO xrp_account_key (
  coin, account, account_id, key_type, master_key, master_seed, master_seed_hex,
  public_key, public_key_hex, is_regular_key_pair, allocated_id, addr_status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertXRPAccountKeyParams struct {
	Coin             XrpAccountKeyCoin
	Account          XrpAccountKeyAccount
	AccountID        string
	KeyType          int8
	MasterKey        string
	MasterSeed       string
	MasterSeedHex    string
	PublicKey        string
	PublicKeyHex     string
	IsRegularKeyPair bool
	AllocatedID      int64
	AddrStatus       int8
}

func (q *Queries) InsertXRPAccountKey(ctx context.Context, arg InsertXRPAccountKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertXRPAccountKey,
		arg.Coin,
		arg.Account,
		arg.AccountID,
		arg.KeyType,
		arg.MasterKey,
		arg.MasterSeed,
		arg.MasterSeedHex,
		arg.PublicKey,
		arg.PublicKeyHex,
		arg.IsRegularKeyPair,
		arg.AllocatedID,
		arg.AddrStatus,
	)
}

const updateXRPAccountKeyAddrStatus = `-- name: UpdateXRPAccountKeyAddrStatus :execresult
UPDATE xrp_account_key SET addr_status = ?, updated_at = ?
WHERE coin = ? AND account = ? AND account_id = ?
`

type UpdateXRPAccountKeyAddrStatusParams struct {
	AddrStatus int8
	UpdatedAt  sql.NullTime
	Coin       XrpAccountKeyCoin
	Account    XrpAccountKeyAccount
	AccountID  string
}

func (q *Queries) UpdateXRPAccountKeyAddrStatus(ctx context.Context, arg UpdateXRPAccountKeyAddrStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateXRPAccountKeyAddrStatus,
		arg.AddrStatus,
		arg.UpdatedAt,
		arg.Coin,
		arg.Account,
		arg.AccountID,
	)
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: btc_tx_input.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const getBtcTxInputByID = `-- name: GetBtcTxInputByID :one
SELECT id, tx_id, input_txid, input_vout, input_address, input_account, input_amount, input_confirmations, updated_at FROM btc_tx_input
WHERE id = ?
`

func (q *Queries) GetBtcTxInputByID(ctx context.Context, id int64) (BtcTxInput, error) {
	row := q.db.QueryRowContext(ctx, getBtcTxInputByID, id)
	var i BtcTxInput
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.InputTxid,
		&i.InputVout,
		&i.InputAddress,
		&i.InputAccount,
		&i.InputAmount,
		&i.InputConfirmations,
		&i.UpdatedAt,
	)
	return i, err
}

const getBtcTxInputsByTxID = `-- name: GetBtcTxInputsByTxID :many
SELECT id, tx_id, input_txid, input_vout, input_address, input_account, input_amount, input_confirmations, updated_at FROM btc_tx_input
WHERE tx_id = ?
`

func (q *Queries) GetBtcTxInputsByTxID(ctx context.Context, txID int64) ([]BtcTxInput, error) {
	rows, err := q.db.QueryContext(ctx, getBtcTxInputsByTxID, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BtcTxInput
	for rows.Next() {
		var i BtcTxInput
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.InputTxid,
			&i.InputVout,
			&i.InputAddress,
			&i.InputAccount,
			&i.InputAmount,
			&i.InputConfirmations,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBtcTxInput = `-- name: InsertBtcTxInput :execresult
INSERT INTO btc_tx_input (
  tx_id, input_txid, input_vout, input_address, input_account,
  input_amount, input_confirmations, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertBtcTxInputParams struct {
	TxID               int64
	InputTxid          string
	InputVout          uint32
	InputAddress       string
	InputAccount       string
	InputAmount        string
	InputConfirmations uint64
	UpdatedAt          sql.NullTime
}

func (q *Queries) InsertBtcTxInput(ctx context.Context, arg InsertBtcTxInputParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertBtcTxInput,
		arg.TxID,
		arg.InputTxid,
		arg.InputVout,
		arg.InputAddress,
		arg.InputAccount,
		arg.InputAmount,
		arg.InputConfirmations,
		arg.UpdatedAt,
	)
}

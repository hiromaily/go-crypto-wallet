// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
)

type AddressAccount string

const (
	AddressAccountClient  AddressAccount = "client"
	AddressAccountDeposit AddressAccount = "deposit"
	AddressAccountPayment AddressAccount = "payment"
	AddressAccountStored  AddressAccount = "stored"
)

func (e *AddressAccount) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AddressAccount(s)
	case string:
		*e = AddressAccount(s)
	default:
		return fmt.Errorf("unsupported scan type for AddressAccount: %T", src)
	}
	return nil
}

type NullAddressAccount struct {
	AddressAccount AddressAccount
	Valid          bool // Valid is true if AddressAccount is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAddressAccount) Scan(value interface{}) error {
	if value == nil {
		ns.AddressAccount, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AddressAccount.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAddressAccount) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AddressAccount), nil
}

type AddressCoin string

const (
	AddressCoinBtc AddressCoin = "btc"
	AddressCoinBch AddressCoin = "bch"
	AddressCoinEth AddressCoin = "eth"
	AddressCoinXrp AddressCoin = "xrp"
	AddressCoinHyt AddressCoin = "hyt"
)

func (e *AddressCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AddressCoin(s)
	case string:
		*e = AddressCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for AddressCoin: %T", src)
	}
	return nil
}

type NullAddressCoin struct {
	AddressCoin AddressCoin
	Valid       bool // Valid is true if AddressCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAddressCoin) Scan(value interface{}) error {
	if value == nil {
		ns.AddressCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AddressCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAddressCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AddressCoin), nil
}

type BtcTxAction string

const (
	BtcTxActionDeposit  BtcTxAction = "deposit"
	BtcTxActionPayment  BtcTxAction = "payment"
	BtcTxActionTransfer BtcTxAction = "transfer"
)

func (e *BtcTxAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BtcTxAction(s)
	case string:
		*e = BtcTxAction(s)
	default:
		return fmt.Errorf("unsupported scan type for BtcTxAction: %T", src)
	}
	return nil
}

type NullBtcTxAction struct {
	BtcTxAction BtcTxAction
	Valid       bool // Valid is true if BtcTxAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBtcTxAction) Scan(value interface{}) error {
	if value == nil {
		ns.BtcTxAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BtcTxAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBtcTxAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BtcTxAction), nil
}

type BtcTxCoin string

const (
	BtcTxCoinBtc BtcTxCoin = "btc"
	BtcTxCoinBch BtcTxCoin = "bch"
)

func (e *BtcTxCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BtcTxCoin(s)
	case string:
		*e = BtcTxCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for BtcTxCoin: %T", src)
	}
	return nil
}

type NullBtcTxCoin struct {
	BtcTxCoin BtcTxCoin
	Valid     bool // Valid is true if BtcTxCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBtcTxCoin) Scan(value interface{}) error {
	if value == nil {
		ns.BtcTxCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BtcTxCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBtcTxCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BtcTxCoin), nil
}

type PaymentRequestCoin string

const (
	PaymentRequestCoinBtc PaymentRequestCoin = "btc"
	PaymentRequestCoinBch PaymentRequestCoin = "bch"
	PaymentRequestCoinEth PaymentRequestCoin = "eth"
	PaymentRequestCoinXrp PaymentRequestCoin = "xrp"
)

func (e *PaymentRequestCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentRequestCoin(s)
	case string:
		*e = PaymentRequestCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentRequestCoin: %T", src)
	}
	return nil
}

type NullPaymentRequestCoin struct {
	PaymentRequestCoin PaymentRequestCoin
	Valid              bool // Valid is true if PaymentRequestCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentRequestCoin) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentRequestCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentRequestCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentRequestCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentRequestCoin), nil
}

type TxAction string

const (
	TxActionDeposit  TxAction = "deposit"
	TxActionPayment  TxAction = "payment"
	TxActionTransfer TxAction = "transfer"
)

func (e *TxAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxAction(s)
	case string:
		*e = TxAction(s)
	default:
		return fmt.Errorf("unsupported scan type for TxAction: %T", src)
	}
	return nil
}

type NullTxAction struct {
	TxAction TxAction
	Valid    bool // Valid is true if TxAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxAction) Scan(value interface{}) error {
	if value == nil {
		ns.TxAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxAction), nil
}

type TxCoin string

const (
	TxCoinEth TxCoin = "eth"
	TxCoinXrp TxCoin = "xrp"
	TxCoinHyt TxCoin = "hyt"
)

func (e *TxCoin) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxCoin(s)
	case string:
		*e = TxCoin(s)
	default:
		return fmt.Errorf("unsupported scan type for TxCoin: %T", src)
	}
	return nil
}

type NullTxCoin struct {
	TxCoin TxCoin
	Valid  bool // Valid is true if TxCoin is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxCoin) Scan(value interface{}) error {
	if value == nil {
		ns.TxCoin, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxCoin.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxCoin) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxCoin), nil
}

// table for account pubkey
type Address struct {
	// ID
	ID int64
	// coin type code
	Coin AddressCoin
	// account type
	Account AddressAccount
	// wallet address
	WalletAddress string
	// true: address is allocated(used)
	IsAllocated bool
	// updated date
	UpdatedAt sql.NullTime
}

// table for btc transaction info
type BtcTx struct {
	// transaction ID
	ID int64
	// coin type code
	Coin BtcTxCoin
	// action type
	Action BtcTxAction
	// HEX string for unsigned transaction
	UnsignedHexTx string
	// HEX string for signed transaction
	SignedHexTx string
	// Hash for sent transaction
	SentHashTx string
	// total amount of coin to send
	TotalInputAmount string
	// total amount of coin to receive without fee
	TotalOutputAmount string
	// fee
	Fee string
	// current transaction type
	CurrentTxType int8
	// updated date for unsigned transaction created
	UnsignedUpdatedAt sql.NullTime
	// updated date for signed transaction sent
	SentUpdatedAt sql.NullTime
}

// table for input transaction
type BtcTxInput struct {
	// ID
	ID int64
	// tx table ID
	TxID int64
	// txid for input
	InputTxid string
	// vout for input
	InputVout uint32
	// sender address for input
	InputAddress string
	// sender account for input
	InputAccount string
	// amount of coin to send for input
	InputAmount string
	// block confirmations when unspent rpc returned
	InputConfirmations uint64
	// updated date
	UpdatedAt sql.NullTime
}

// table for output transaction
type BtcTxOutput struct {
	// ID
	ID int64
	// tx table ID
	TxID int64
	// receiver address for output
	OutputAddress string
	// receiver account for output
	OutputAccount string
	// amount of coin to receive
	OutputAmount string
	// true: output is for fee
	IsChange bool
	// updated date
	UpdatedAt sql.NullTime
}

// table for eth transaction detail
type EthDetailTx struct {
	// ID
	ID int64
	// eth_tx table ID
	TxID int64
	// UUID
	Uuid string
	// current transaction type
	CurrentTxType int8
	// sender account
	SenderAccount string
	// sender address
	SenderAddress string
	// receiver account
	ReceiverAccount string
	// receiver address
	ReceiverAddress string
	// amount of coin to receive
	Amount uint64
	// fee
	Fee uint64
	// gas limit
	GasLimit uint32
	// nonce
	Nonce uint64
	// HEX string for unsigned transaction
	UnsignedHexTx string
	// HEX string for signed transaction
	SignedHexTx string
	// Hash for sent transaction
	SentHashTx string
	// updated date for unsigned transaction created
	UnsignedUpdatedAt sql.NullTime
	// updated date for signed transaction sent
	SentUpdatedAt sql.NullTime
}

// table for payment request
type PaymentRequest struct {
	// ID
	ID int64
	// coin type code
	Coin PaymentRequestCoin
	// tx table ID for payment action
	PaymentID sql.NullInt64
	// sender address
	SenderAddress string
	// sender account
	SenderAccount string
	// receiver address
	ReceiverAddress string
	// amount of coin to send
	Amount string
	// true: unsigned transaction is created
	IsDone bool
	// updated date
	UpdatedAt sql.NullTime
}

// table for eth/xrp transaction info
type Tx struct {
	// transaction ID
	ID int64
	// coin type code
	Coin TxCoin
	// action type
	Action TxAction
	// updated date
	UpdatedAt sql.NullTime
}

// table for xrp transaction detail
type XrpDetailTx struct {
	// ID
	ID int64
	// xrp_tx table ID
	TxID int64
	// UUID
	Uuid string
	// current transaction type
	CurrentTxType int8
	// sender account
	SenderAccount string
	// sender address
	SenderAddress string
	// receiver account
	ReceiverAccount string
	// receiver address
	ReceiverAddress string
	// amount of coin to receive
	Amount string
	// xrp tx type like Payment
	XrpTxType string
	// tx fee
	Fee string
	// tx flags
	Flags uint64
	// tx LastLedgerSequence
	LastLedgerSequence uint64
	// tx Sequence
	Sequence uint64
	// tx SigningPubKey
	SigningPubkey string
	// tx TxnSignature
	TxnSignature string
	// tx Hash
	Hash string
	// tx earliest_ledger_version after sending tx
	EarliestLedgerVersion uint64
	// signed tx id
	SignedTxID string
	// sent tx blob
	TxBlob string
	// updated date for signed transaction sent
	SentUpdatedAt sql.NullTime
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: btc_tx.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteAllBtcTx = `-- name: DeleteAllBtcTx :execresult
DELETE FROM btc_tx
`

func (q *Queries) DeleteAllBtcTx(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteAllBtcTx)
}

const getBtcTxByID = `-- name: GetBtcTxByID :one
SELECT id, coin, action, unsigned_hex_tx, signed_hex_tx, sent_hash_tx, total_input_amount, total_output_amount, fee, current_tx_type, unsigned_updated_at, sent_updated_at FROM btc_tx
WHERE id = ?
`

func (q *Queries) GetBtcTxByID(ctx context.Context, id int64) (BtcTx, error) {
	row := q.db.QueryRowContext(ctx, getBtcTxByID, id)
	var i BtcTx
	err := row.Scan(
		&i.ID,
		&i.Coin,
		&i.Action,
		&i.UnsignedHexTx,
		&i.SignedHexTx,
		&i.SentHashTx,
		&i.TotalInputAmount,
		&i.TotalOutputAmount,
		&i.Fee,
		&i.CurrentTxType,
		&i.UnsignedUpdatedAt,
		&i.SentUpdatedAt,
	)
	return i, err
}

const getBtcTxCountByUnsignedHex = `-- name: GetBtcTxCountByUnsignedHex :one
SELECT COUNT(*) as count FROM btc_tx
WHERE coin = ? AND action = ? AND unsigned_hex_tx = ?
`

type GetBtcTxCountByUnsignedHexParams struct {
	Coin          BtcTxCoin
	Action        BtcTxAction
	UnsignedHexTx string
}

func (q *Queries) GetBtcTxCountByUnsignedHex(ctx context.Context, arg GetBtcTxCountByUnsignedHexParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBtcTxCountByUnsignedHex, arg.Coin, arg.Action, arg.UnsignedHexTx)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBtcTxIDBySentHash = `-- name: GetBtcTxIDBySentHash :one
SELECT id FROM btc_tx
WHERE coin = ? AND action = ? AND sent_hash_tx = ?
`

type GetBtcTxIDBySentHashParams struct {
	Coin       BtcTxCoin
	Action     BtcTxAction
	SentHashTx string
}

func (q *Queries) GetBtcTxIDBySentHash(ctx context.Context, arg GetBtcTxIDBySentHashParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBtcTxIDBySentHash, arg.Coin, arg.Action, arg.SentHashTx)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getBtcTxIDByUnsignedHex = `-- name: GetBtcTxIDByUnsignedHex :one
SELECT id FROM btc_tx
WHERE coin = ? AND action = ? AND unsigned_hex_tx = ?
`

type GetBtcTxIDByUnsignedHexParams struct {
	Coin          BtcTxCoin
	Action        BtcTxAction
	UnsignedHexTx string
}

func (q *Queries) GetBtcTxIDByUnsignedHex(ctx context.Context, arg GetBtcTxIDByUnsignedHexParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBtcTxIDByUnsignedHex, arg.Coin, arg.Action, arg.UnsignedHexTx)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getBtcTxSentHashList = `-- name: GetBtcTxSentHashList :many
SELECT sent_hash_tx FROM btc_tx
WHERE coin = ? AND action = ? AND current_tx_type = ?
`

type GetBtcTxSentHashListParams struct {
	Coin          BtcTxCoin
	Action        BtcTxAction
	CurrentTxType int8
}

func (q *Queries) GetBtcTxSentHashList(ctx context.Context, arg GetBtcTxSentHashListParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getBtcTxSentHashList, arg.Coin, arg.Action, arg.CurrentTxType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var sent_hash_tx string
		if err := rows.Scan(&sent_hash_tx); err != nil {
			return nil, err
		}
		items = append(items, sent_hash_tx)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBtcTx = `-- name: InsertBtcTx :execresult
INSERT INTO btc_tx (
  coin, action, unsigned_hex_tx, signed_hex_tx, sent_hash_tx,
  total_input_amount, total_output_amount, fee, current_tx_type,
  unsigned_updated_at, sent_updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertBtcTxParams struct {
	Coin              BtcTxCoin
	Action            BtcTxAction
	UnsignedHexTx     string
	SignedHexTx       string
	SentHashTx        string
	TotalInputAmount  string
	TotalOutputAmount string
	Fee               string
	CurrentTxType     int8
	UnsignedUpdatedAt sql.NullTime
	SentUpdatedAt     sql.NullTime
}

func (q *Queries) InsertBtcTx(ctx context.Context, arg InsertBtcTxParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertBtcTx,
		arg.Coin,
		arg.Action,
		arg.UnsignedHexTx,
		arg.SignedHexTx,
		arg.SentHashTx,
		arg.TotalInputAmount,
		arg.TotalOutputAmount,
		arg.Fee,
		arg.CurrentTxType,
		arg.UnsignedUpdatedAt,
		arg.SentUpdatedAt,
	)
}

const updateBtcTx = `-- name: UpdateBtcTx :exec
UPDATE btc_tx
SET coin = ?, action = ?, unsigned_hex_tx = ?, signed_hex_tx = ?, sent_hash_tx = ?,
    total_input_amount = ?, total_output_amount = ?, fee = ?, current_tx_type = ?,
    unsigned_updated_at = ?, sent_updated_at = ?
WHERE id = ?
`

type UpdateBtcTxParams struct {
	Coin              BtcTxCoin
	Action            BtcTxAction
	UnsignedHexTx     string
	SignedHexTx       string
	SentHashTx        string
	TotalInputAmount  string
	TotalOutputAmount string
	Fee               string
	CurrentTxType     int8
	UnsignedUpdatedAt sql.NullTime
	SentUpdatedAt     sql.NullTime
	ID                int64
}

func (q *Queries) UpdateBtcTx(ctx context.Context, arg UpdateBtcTxParams) error {
	_, err := q.db.ExecContext(ctx, updateBtcTx,
		arg.Coin,
		arg.Action,
		arg.UnsignedHexTx,
		arg.SignedHexTx,
		arg.SentHashTx,
		arg.TotalInputAmount,
		arg.TotalOutputAmount,
		arg.Fee,
		arg.CurrentTxType,
		arg.UnsignedUpdatedAt,
		arg.SentUpdatedAt,
		arg.ID,
	)
	return err
}

const updateBtcTxAfterSent = `-- name: UpdateBtcTxAfterSent :execresult
UPDATE btc_tx
SET current_tx_type = ?, signed_hex_tx = ?, sent_hash_tx = ?, sent_updated_at = ?
WHERE id = ?
`

type UpdateBtcTxAfterSentParams struct {
	CurrentTxType int8
	SignedHexTx   string
	SentHashTx    string
	SentUpdatedAt sql.NullTime
	ID            int64
}

func (q *Queries) UpdateBtcTxAfterSent(ctx context.Context, arg UpdateBtcTxAfterSentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateBtcTxAfterSent,
		arg.CurrentTxType,
		arg.SignedHexTx,
		arg.SentHashTx,
		arg.SentUpdatedAt,
		arg.ID,
	)
}

const updateBtcTxType = `-- name: UpdateBtcTxType :execresult
UPDATE btc_tx
SET current_tx_type = ?
WHERE id = ?
`

type UpdateBtcTxTypeParams struct {
	CurrentTxType int8
	ID            int64
}

func (q *Queries) UpdateBtcTxType(ctx context.Context, arg UpdateBtcTxTypeParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateBtcTxType, arg.CurrentTxType, arg.ID)
}

const updateBtcTxTypeBySentHash = `-- name: UpdateBtcTxTypeBySentHash :execresult
UPDATE btc_tx
SET current_tx_type = ?
WHERE coin = ? AND action = ? AND sent_hash_tx = ?
`

type UpdateBtcTxTypeBySentHashParams struct {
	CurrentTxType int8
	Coin          BtcTxCoin
	Action        BtcTxAction
	SentHashTx    string
}

func (q *Queries) UpdateBtcTxTypeBySentHash(ctx context.Context, arg UpdateBtcTxTypeBySentHashParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateBtcTxTypeBySentHash,
		arg.CurrentTxType,
		arg.Coin,
		arg.Action,
		arg.SentHashTx,
	)
}
